Booleans
	In [352]: a = True
	In [353]: b = False
	In [354]: type(a)
	Out[354]: bool



Numbers
	Don't bother with long, they're ints
	In [111]: i = 42
	In [112]: f = 42.42
	In [113]: type(i)
	Out[113]: int
	In [114]: type(f)
	Out[114]: float
	In [115]: float(i)
	Out[115]: 42.0
	In [116]: int(f)
	Out[116]: 42


	
Strings
	In [117]: str(f)
	Out[117]: '42.42'

	s = "plop"
	In [19]: s[1]
	Out[19]: 'l'
	In [30]: s[0:3]
	Out[30]: 'plo'
	
	In [33]: v1 = 42
	In [34]: print("Value of s: " + s + " . And v1: " + v1)
	TypeError: cannot concatenate 'str' and 'int' objects
	In [52]: print("Value of s: " + s + " . And v1: " + str(v1))
	Value of s: plop . And v1: 42
	
	In [48]: print("This is a string: %s and this an integer: %d" % ('plop', 42))
	This is a string: plop and this an integer: 42
	In [53]: print("This is a string: %s and this an integer: %d" % (s, v1))
	This is a string: plop and this an integer: 42
	In [53]: print("This is a string: %s and this an integer: %s" % (s, v1))
	This is a string: plop and this an integer: 42
	
	In [54]: print("Value of s: {} . And v1: {}".format(s, v1))     (since python 2.7)
	Value of s: plop . And v1: 42
	In [54]: print("Value of s: {0} . And v1: {1}".format(s, v1))
	Value of s: plop . And v1: 42
	In [55]: print("Value of v1: {1} . And s: {0} . And v1 again: {1}".format(s, v1))
	Value of v1: 42 . And s: plop . And v1 again: 42
	In [90]: print("plop {} " "plop".format(s))
	plop plop plop
	
	In [12]: s.capitalize()
	Out[12]: 'Plop'
	In [82]: s.upper()  / lower
	Out[82]: 'PLOP'
	
	In [16]: s.count("p")
	Out[16]: 2
	In [25]: "pl" in s
	Out[25]: True
	In [71]: s.find('o')
	Out[71]: 2
	
	In [62]: s.encode(encoding='base64')
	Out[62]: 'cGxvcA==\n'
	In [63]: a = s.encode(encoding='base64')
	In [64]: a.decode(encoding='base64')
	Out[64]: 'plop'
	
	In [66]: s.startswith('pl')
	Out[66]: True
	In [67]: s.endswith('dd')
	Out[67]: False

	In [78]: len(s)
	Out[78]: 4
	
	In [84]: s.replace('pl', 't')
	Out[84]: 'top'
	
	In [86]: "This_is_a_sentence".split("_")
	Out[86]: ['This', 'is', 'a', 'sentence']
	In [88]: " ".join(['This', 'is', 'a', 'sentence'])
	Out[88]: 'This is a sentence'
	
	In [87]: "      This is a sentence       ".strip()
	Out[87]: 'This is a sentence'
	
	In [91]: long = """this is a long string that is made up of
	    ...: several lines and non-printable characters such as
	    ...: TAB ( \t ) and they will show up that way when displayed.
	    ...: NEWLINEs within the string, whether explicitly given like
	    ...: this within the brackets [ \n ], or just a NEWLINE within
	    ...: the variable assignment will also show up.
	    ...: """
	In [93]: print(long)
	this is a long string that is made up of
	several lines and non-printable characters such as
	TAB (          ) and they will show up that way when displayed.
	NEWLINEs within the string, whether explicitly given like
	this within the brackets [ 
	 ], or just a NEWLINE within
	the variable assignment will also show up.
	
	In [160]: a = input("Please type your input: ")
	Please type your input: "sasasasas"
	In [161]: a
	Out[161]: 'sasasasas'
	In [160]: a = raw_input("Please type your input: ")
	Please type your input: sasasasas
	In [161]: a
	Out[161]: 'sasasasas'
	


Lists
	In [125]: l1 = [1, 2, 3, 4, 5, 6]
	In [127]: l2 = [1, "plop", 42.42, [1, 2, 3]]
	
	In [133]: print(l2[2])
	42.42
	In [134]: print(l1[1:3])
	[2, 3]
	In [135]: print(l1[3:])
	[4, 5, 6]
	In [136]: print(l1[-1])
	6

	In [136]: l2[0] = 0
	In [137]: l2
	Out[137]: [0, 'plop', 42.42, [1, 2, 3]]
	
	In [138]: del l2[0]
	In [139]: l2
	Out[139]: ['plop', 42.42, [1, 2, 3]]
	
	In [140]: len(l1)
	Out[140]: 6
	
	In [141]: [1, 2, 3] + [4, 5, 6]
	Out[141]: [1, 2, 3, 4, 5, 6]
	
	In [142]: 3 in [1, 2, 3]
	Out[142]: True
	In [149]: l1.index(1)
	Out[149]: 0
	In [145]: l1.count(1)
	Out[145]: 1
	
	In [143]: l1.append(7)
	In [144]: l1
	Out[144]: [1, 2, 3, 4, 5, 6, 7]
	
	In [147]: l1.pop()
	Out[147]: 7
	In [148]: l1
	Out[148]: [1, 2, 3, 4, 5, 6]
	
	In [150]: l1.insert(0, 0)
	In [151]: l1
	Out[151]: [0, 1, 2, 3, 4, 5, 6]
	
	In [152]: l1.remove(6)
	In [153]: l1
	Out[153]: [0, 1, 2, 3, 4, 5]
	
	In [154]: l1.reverse()
	In [155]: l1
	Out[155]: [5, 4, 3, 2, 1, 0]


	
Tuples
	In [162]: t1 = (1,2,3)
	In [163]: t2 = (4,5,6)
	
	In [165]: t1[0]
	Out[165]: 1
	
	In [173]: t1[-1]
	Out[173]: 3
	
	Tuples are immutable !
	In [166]: t1[0] = 1
	---------------------------------------------------------------------------
	TypeError                                 Traceback (most recent call last)
	<ipython-input-166-9e1f4de27f17> in <module>()
	----> 1 t1[0] = 1
	TypeError: 'tuple' object does not support item assignment
	
	In [168]: len(t1)
	Out[168]: 3
	
	In [164]: t1+t2
	Out[164]: (1, 2, 3, 4, 5, 6)
	
	In [169]: 3 in t1
	Out[169]: True
	
	In [170]: t1.count(1)
	Out[170]: 1
	
	In [171]: t1.index(1)
	Out[171]: 0
	
	In [174]: t = 1, 2, 3
	In [175]: t
	Out[175]: (1, 2, 3)


	
Dictionaries
	In [176]: d = {"name": "memo", "sex": "male", "age": 25}
	In [178]: print(d)
	{'age': 25, 'name': 'memo', 'sex': 'male'}
	
	- Dict are non-ordered but their order is static
	- No duplicate key
	- Keys can be: String, Numbers, Tuples
	
	In [184]: d['name'] = "m3m0"
	In [184]: d['height'] = 1.75
	In [186]: print(d)
	{'age': 26, 'height': 1.75, 'name': 'm3m0', 'sex': 'male'}
	
	In [183]: print(d['age'])
	25
	In [191]: d.get("age")
	Out[191]: 26
	In [192]: d.get("plop", "nope")
	Out[192]: 'nope'
	
	In [193]: len(d)
	Out[193]: 4
	
	In [197]: d.items()
	Out[197]: [('age', 26), ('height', 1.75), ('name', 'memo'), ('sex', 'male')]
	In [198]: d.keys()
	Out[198]: ['age', 'height', 'name', 'sex']
	In [199]: d.values()
	Out[199]: [26, 1.75, 'memo', 'male']
	


Sets and frozensets
	In [363]: s1 = {1,2,3}
	In [364]: s2 = {1, 'a', "plop"}
	
	In [367]: s1 = {1, 2, 3, 3, 3}
	In [368]: s1
	Out[368]: {1, 2, 3}
	
	In [376]: s1.add(0)
	In [377]: s1.remove(3)
	In [378]: s1
	Out[378]: {0, 1, 2}
	
	In [374]: len(s1)
	Out[374]: 3
	
	In [375]: 1 in s1
	Out[375]: True
	
	In [363]: s1 = {0,1,2}
	In [379]: s2 = {2,3,4}
	In [382]: s1.difference(s2) #In s1 but not in s2
	Out[382]: {0, 1}
	In [388]: s1.symmetric_difference(s2) #Not in both
	Out[388]: {0, 1, 3, 4}
	In [383]: s1.intersection(s2) #In both
	Out[383]: {2}
	In [387]: s1.union(s2) #In s1 or s2
	Out[387]: {0, 1, 2, 3, 4}
	
	In [384]: s1.isdisjoint(s2) #No common elements
	Out[384]: False
	In [385]: s1.issubset(s2) #All s1 elements are also part of s2
	Out[385]: False
	In [386]: s1.issuperset(s2)  #All s2 elements are also part of s1
	Out[386]: False
	
	Frozensets are like sets but immutable and don't have the add() and remove() methods
	In [371]: a = frozenset([1,2,3])
	In [372]: a
	Out[372]: frozenset({1, 2, 3})



None
	In [357]: a = None
	In [358]: type(a)
	Out[358]: NoneType
